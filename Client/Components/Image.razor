@implements IDisposable
@using OpenCvSharp;
@using SpawnDev.BlazorJS.JSObjects;
<canvas @onclick="SelectImage" style="zoom: @(Zoom)%; border:@(_selected? "3px solid blue":"1px solid grey");" @ref=canvasSrcRef></canvas>

@code {
    ElementReference canvasSrcRef;
    [Inject] IImageDataHandler ImageDataHandler { get; set; } = default!;
    [Parameter] public Guid CurrentData { get; set; }
    [Parameter] public int Zoom { get; set; } = 100;
    private bool _selected;

    public void SelectImage()
    {
        ImageDataHandler.SelectImage(CurrentData);
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        ImageDataHandler.ImageSelected += OnImageSelected;
        ImageDataHandler.ReRenderImage += OnReRenderImage;
        var data = ImageDataHandler.GetRenderData(CurrentData);
        if (data.PreviousImage == null) await RenderImage(data.OriginalImage);
        else await RenderPipelineImage(data);
        await base.OnAfterRenderAsync(firstRender);
    }
    public async Task OnReRenderImage(Guid guid)
    {
        if (CurrentData != guid) return;
        var data = ImageDataHandler.GetRenderData(CurrentData);
        await RenderPipelineImage(data);
        StateHasChanged();
    }
    public Task OnImageSelected(Guid guid)
    {
        if (CurrentData != guid) _selected = false;
        else _selected = true;
        StateHasChanged();
        return Task.CompletedTask;
    }
    public async Task RenderImage(string image)
    {
        using var canvasSrcEl = new HTMLCanvasElement(canvasSrcRef);
        using var canvasSrcCtx = canvasSrcEl.Get2DContext();
        using var src = new Mat();
        await src.LoadImageURL(image);
        src.DrawOnCanvas(canvasSrcCtx, true);
        await InvokePictureRendered(src);
    }
    public async Task RenderPipelineImage(MatImageData pipelineAction)
    {
        using var canvasSrcEl = new HTMLCanvasElement(canvasSrcRef);
        using var canvasSrcCtx = canvasSrcEl.Get2DContext();
        using var dest = new Mat();
        var action = pipelineAction.GetAction(ImageDataHandler);
        action(dest);
        dest.DrawOnCanvas(canvasSrcCtx, true);
        await InvokePictureRendered(dest);
    }
    public async Task InvokePictureRendered(Mat src)
    {
        await ImageDataHandler.ImageRendered(new MatImageData()
            {
                Guid = CurrentData,
                Height = src.Height,
                Width = src.Width,
                RGBABytes = src.GetRGBABytes()
            });
    }
    public void Dispose()
    {
        ImageDataHandler.ImageSelected -= OnImageSelected;
    }
}
