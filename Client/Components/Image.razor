@using OpenCvSharp;
@using SpawnDev.BlazorJS.JSObjects;
<canvas style="zoom: @(Zoom)%; border: 1px solid grey;" @ref=canvasSrcRef></canvas>

@code {
    ElementReference canvasSrcRef;
    [Inject] IImageDataHandler ImageDataHandler { get; set; } = default!;
    [Parameter] public Guid CurrentData { get; set; }
    [Parameter] public int Zoom { get; set; } = 100;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        var data = ImageDataHandler.GetRenderData(CurrentData);
        if (!string.IsNullOrEmpty(data.OriginalImage)) await RenderImage(data.OriginalImage);
        else if (data.PipelineAction != null) await RenderPipelineImage(data.PipelineAction);
        await base.OnAfterRenderAsync(firstRender);
    }
    public async Task RenderImage(string image)
    {
        Console.WriteLine("render im");
        using var canvasSrcEl = new HTMLCanvasElement(canvasSrcRef);
        using var canvasSrcCtx = canvasSrcEl.Get2DContext();
        using var src = new Mat();
        await src.LoadImageURL(image);
        src.DrawOnCanvas(canvasSrcCtx, true);
        await InvokePictureRendered(src);

    }
    public async Task RenderPipelineImage(Action<Mat> pipelineAction)
    {
        Console.WriteLine("render pipe");
        using var canvasSrcEl = new HTMLCanvasElement(canvasSrcRef);
        using var canvasSrcCtx = canvasSrcEl.Get2DContext();
        using var dest = new Mat();
        pipelineAction(dest);
        dest.DrawOnCanvas(canvasSrcCtx, true);
        await InvokePictureRendered(dest);
    }
    public async Task InvokePictureRendered(Mat src)
    {
        await ImageDataHandler.ImageRendered(new MatImageData()
            {
                Guid = CurrentData,
                Height = src.Height,
                Width = src.Width,
                RGBABytes = src.GetRGBABytes()
            });
    }
}
