@using OpenCvSharp;
@using SpawnDev.BlazorJS.JSObjects;
<canvas style="zoom: @(Zoom)%; border: 1px solid grey;" @ref=canvasSrcRef></canvas>

@code {
    ElementReference canvasSrcRef;
    [Parameter] public string ImageData { get; set; } = "";
    [Parameter] public MatImageData? CurrentData { get; set; }
    [Parameter] public int Zoom { get; set; } = 100;
    [Parameter] public EventCallback<MatImageData> OnImageRendered { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        if (CurrentData?.PipelineAction != null) await RenderPipelineImage(CurrentData.PipelineAction);
        else if (!string.IsNullOrEmpty(ImageData)) await RenderImage(ImageData);
        await base.OnAfterRenderAsync(firstRender);
    }
    public async Task RenderImage(string image)
    {
        using var canvasSrcEl = new HTMLCanvasElement(canvasSrcRef);
        using var canvasSrcCtx = canvasSrcEl.Get2DContext();
        using var src = new Mat();
        await src.LoadImageURL(image);
        src.DrawOnCanvas(canvasSrcCtx, true);
        await InvokePictureRendered(src);

    }
    public async Task RenderPipelineImage(Action<Mat> pipelineAction)
    {
        using var canvasSrcEl = new HTMLCanvasElement(canvasSrcRef);
        using var canvasSrcCtx = canvasSrcEl.Get2DContext();
        using var dest = new Mat();
        pipelineAction(dest);
        dest.DrawOnCanvas(canvasSrcCtx, true);
        await InvokePictureRendered(dest);
    }
    public async Task InvokePictureRendered(Mat src)
    {
        await OnImageRendered.InvokeAsync(new MatImageData()
            {
                PipelineStep = CurrentData?.PipelineStep + 1 ?? 1,
                RGBABytes = src.GetRGBABytes(),
                Height = src.Height,
                Width = src.Width
            });
    }
}
